// generated by gcg
package {{underline .DBName}}

import (
  "time"
  "fmt"
)

var _ = time.Now

type {{upperCamel .TableName}} struct {
  {{ range $i, $v := .Columns }}
  {{upperCamel $v.Field}} {{$v.GoType}} `db:"{{$v.Field}}" json:"{{$v.Field}}"` {{end}}
}

/*
save
*/
func (obj *{{upperCamel .TableName}}) Save() int{
  var sql = ""
  var id int
  database := GetDB()
  if (obj.Id == {{.primaryKeyDefault}} {
    sql ="INSERT INTO `{{.TableName}}` ({{getInsertColumn .Columns}}) values ({{getTableFieldCounts .Columns}})"
    res := database.MustExec(sql,{{getObjColumn .Columns}} )
    retid, _ := res.LastInsertId()
    id = int(retid)
  }else{
      sql ="update `{{.TableName}}` set {{getUpdateColumn .Columns}} where id=?"
      res := database.MustExec(sql,{{getObjColumn .Columns}},obj.Id )
      retid, _ := res.LastInsertId()
  	  id = int(retid)
  }
  return id
}

/*
delete
*/
func (obj *{{upperCamel .TableName}}) Delete() bool{
    database := GetDB()
    sql := "update `{{.TableName}}` set deleted = 1  where id=?"
    database.MustExec(sql, obj.Id)
    return true
}
/*
Get List by Where
*/
func Get{{upperCamel .TableName}}Where(cond string, args ...interface{}) []*{{upperCamel .TableName}} {
  objs := []*{{upperCamel .TableName}}{}
  database := GetDB()
  sql :="SELECT {{getTableFieldNames .Columns}} FROM `{{.TableName}}` WHERE deleted = 0 "
  if cond != ""{
    sql+=" and " + cond +"=? "
  }
  err := database.Select(&objs, sql, args...)
  if err != nil {
    fmt.Println(err)
  }
  return objs
}

/*
Get First by Where
*/
func Get{{upperCamel .TableName}}First(cond string, args ...interface{})  *{{upperCamel .TableName}} {
  obj := &{{upperCamel .TableName}}{}
  database := GetDB()
  sql :="SELECT {{getTableFieldNames .Columns}} FROM `{{.TableName}}` WHERE deleted = 0 "
  if cond != ""{
      sql+=" and " + cond +"=? "
  }
  sql+=" LIMIT 1"
  err := database.QueryRowx(sql, args...).StructScan(obj)
  if err != nil {
    fmt.Println(err)
  }
  return obj
}
